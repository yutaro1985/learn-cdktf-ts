import { Construct } from "constructs";
import {
  VariableType,
  TerraformVariable,
  Fn,
  Op,
  Token,
  conditional,
  TerraformIterator,
  TerraformOutput,
} from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { DataAwsRegion } from "../.gen/providers/aws/data-aws-region";
import { SecurityGroup } from "../.gen/providers/aws/security-group";
import { SecurityGroupRule } from "../.gen/providers/aws/security-group-rule";
import * as VpcEndpoints from "../.gen/modules/vpc-endpoints";
import * as Vpc from "../.gen/modules/vpc";
class MyVpc extends Construct {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    /*Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
    You can read more about this at https://cdk.tf/variables*/
    const azSuffixes = new TerraformVariable(this, "az_suffixes", {
      default: ["a", "c", "d"],
      description: "リージョン内のAZを表すアルファベットのリスト",
      type: VariableType.list(VariableType.STRING),
    });
    const createSsmEndpoint = new TerraformVariable(
      this,
      "create_ssm_endpoint",
      {
        default: false,
        type: VariableType.BOOL,
      }
    );
    const env = new TerraformVariable(this, "env", {
      description: "リソース名などに付与される環境識別文字列 (dev/stg/prod)",
      type: VariableType.STRING,
    });
    const projectName = new TerraformVariable(this, "project_name", {
      description:
        "プロジェクト全体で使う名前。これを使って各リソースにPJ名を入れる",
      type: VariableType.STRING,
    });
    const vpcCidrBlock = new TerraformVariable(this, "vpc_cidr_block", {
      description: "VPCのCidrブロック",
      validation: [
        {
          errorMessage:
            'You must set the input variable \\"vpc_cidr_block\\" to the Private Address Space range of RFC 1918.',
          condition:
            '${can(regex("(^10\\\\..+)|(^172\\\\.(1[6-9]|2[0-9]|3[0-1])\\\\..+)|(^192\\\\.168\\\\..+)", var.vpc_cidr_block))}',
        },
      ],
      type: VariableType.STRING,
    });
    const azCount = Fn.lengthOf(azSuffixes.value);
    const databaseSubnetsPrefixes = Array.from(
      { length: azCount },
      (_, index) => (azCount * 2 + index).toString()
    );
    const enableFlowLogs = env.value === "prod";
    const publicSubnetsPrefixes = Array.from({ length: azCount }, (_, index) =>
      index.toString()
    );
    //   "${[ for num in ${" + Fn.range(0, Token.asNumber(azCount)) + "} : num]}";
    const vpcName = "${" + projectName.value + "}-vpc-${" + env.value + "}";
    const vpc = new Vpc.Vpc(this, "vpc", {
      assignIpv6AddressOnCreation: true,
      azs: azSuffixes.value.map((s: string) => {
        return DataAwsRegion.name + s;
      }),
      cidr: vpcCidrBlock.value,
      createDatabaseSubnetGroup: true,
      createDatabaseSubnetRouteTable: true,
      createEgressOnlyIgw: true,
      createFlowLogCloudwatchIamRole: enableFlowLogs,
      createFlowLogCloudwatchLogGroup: enableFlowLogs,
      createIgw: true,
      databaseSubnetIpv6Prefixes: databaseSubnetsPrefixes,
      databaseSubnets: databaseSubnetsPrefixes.map((num) => {
        return `cidrsubnet(${vpcCidrBlock}, 4, ${num})`;
      }),
      defaultNetworkAclTags: {
        Name: projectName.value + "-default-acl-" + env.value,
      },
      defaultSecurityGroupTags: {
        Name: projectName.value + "-default-sg-" + env.value,
      },
      enableDhcpOptions: true,
      enableDnsHostnames: true,
      enableDnsSupport: true,
      enableFlowLog: enableFlowLogs,
      enableIpv6: true,
      enableNatGateway: false,
      enableVpnGateway: false,
      manageDefaultNetworkAcl: true,
      manageDefaultRouteTable: false,
      manageDefaultSecurityGroup: true,
      name: vpcName,
      publicSubnetIpv6Prefixes: publicSubnetsPrefixes,
      publicSubnets: publicSubnetsPrefixes.map((num) => {
        return `cidrsubnet(${vpcCidrBlock}, 4, ${num})`;
      }),
    /*In most cases loops should be handled in the programming language context and 
    not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
    you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
    you need to keep this like it is.*/
    const vpcTlsForEachIterator = TerraformIterator.fromList(
      Token.asAny(
        conditional(
          createSsmEndpoint.value,
          Fn.toset([vpc.vpcIdOutput]),
          Fn.toset([])
        )
      )
    );
    const vpcTls = new SecurityGroup(this, "vpc_tls", {
      description: "Allow TLS inbound traffic",
      ingress: [
        {
          cidrBlocks: [Token.asString(vpc.vpcCidrBlockOutput)],
          description: "TLS from VPC",
          fromPort: 443,
          protocol: "tcp",
          toPort: 443,
        },
      ],
      namePrefix: "${" + vpcName + "}-vpc_tls",
      vpcId: Token.asString(vpcTlsForEachIterator.value),
      forEach: vpcTlsForEachIterator,
    });
    new SecurityGroupRule(this, "vpc_default_self", {
      fromPort: 0,
      protocol: "all",
      securityGroupId: Token.asString(vpc.defaultSecurityGroupIdOutput),
      sourceSecurityGroupId: Token.asString(vpc.defaultSecurityGroupIdOutput),
      toPort: 0,
      type: "ingress",
    });
    new DataAwsRegion(this, "current", {});
    new TerraformOutput(this, "outputs", {
      value: vpc,
    });
    new VpcEndpoints.VpcEndpoints(this, "endpoints", {
      endpoints: [
        {
          ec2messages: [
            {
              private_dns_enabled: true,
              service: "ec2messages",
              subnet_ids: vpc.privateSubnetsOutput,
            },
          ],
          ssm: [
            {
              private_dns_enabled: true,
              security_group_ids: [
                Fn.lookupNested(Fn.lookupNested(vpcTls, [vpc.vpcIdOutput]), [
                  "id",
                ]),
              ],
              service: "ssm",
              subnet_ids: vpc.privateSubnetsOutput,
            },
          ],
          ssmmessages: [
            {
              private_dns_enabled: true,
              service: "ssmmessages",
              subnet_ids: vpc.privateSubnetsOutput,
            },
          ],
        },
      ],
      forEach: conditional(
        createSsmEndpoint.value,
        Fn.toset([vpc.vpcIdOutput]),
        Fn.toset([])
      ),
      securityGroupIds: [vpc.defaultSecurityGroupIdOutput],
      vpcId: "${each.value}",
    });
  }
}
const azCount = Fn.lengthOf(azSuffixes.value);

// later...

const databaseSubnetIpv6Prefixes = Array.from(
  { length: azCount }, 
  (_, index) => (azCount * 2 + index).toString()
);
