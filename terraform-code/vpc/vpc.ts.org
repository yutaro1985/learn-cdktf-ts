import { Construct } from "constructs";
import {
  VariableType,
  TerraformVariable,
  Fn,
  Op,
  Token,
  conditional,
  TerraformIterator,
  TerraformOutput,
} from "cdktf";
/*
 * Provider bindings are generated by running `cdktf get`.
 * See https://cdk.tf/provider-generation for more details.
 */
import { DataAwsRegion } from "../.gen/providers/aws/data-aws-region";
import { SecurityGroup } from "../.gen/providers/aws/security-group";
import { SecurityGroupRule } from "./.gen/providers/aws/security-group-rule";
import * as VpcEndpoints from "./.gen/modules/terraform-aws-modules/aws/vpc/modules/vpc-endpoints";
import * as Vpc from "./.gen/modules/terraform-aws-modules/aws/vpc";
class MyConvertedCode extends Construct {
  constructor(scope: Construct, name: string) {
    super(scope, name);
    /*Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
    You can read more about this at https://cdk.tf/variables*/
    const azSuffixes = new TerraformVariable(this, "az_suffixes", {
      default: ["a", "c", "d"],
      description:
        "\u30EA\u30FC\u30B8\u30E7\u30F3\u5185\u306EAZ\u3092\u8868\u3059\u30A2\u30EB\u30D5\u30A1\u30D9\u30C3\u30C8\u306E\u30EA\u30B9\u30C8",
      type: VariableType.list(VariableType.STRING),
    });
    const createSsmEndpoint = new TerraformVariable(
      this,
      "create_ssm_endpoint",
      {
        default: false,
        type: VariableType.BOOL,
      }
    );
    const env = new TerraformVariable(this, "env", {
      description:
        "\u30EA\u30BD\u30FC\u30B9\u540D\u306A\u3069\u306B\u4ED8\u4E0E\u3055\u308C\u308B\u74B0\u5883\u8B58\u5225\u6587\u5B57\u5217 (dev/stg/prod)",
      type: VariableType.STRING,
    });
    const projectName = new TerraformVariable(this, "project_name", {
      description:
        "\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u5168\u4F53\u3067\u4F7F\u3046\u540D\u524D\u3002\u3053\u308C\u3092\u4F7F\u3063\u3066\u5404\u30EA\u30BD\u30FC\u30B9\u306BPJ\u540D\u3092\u5165\u308C\u308B",
      type: VariableType.STRING,
    });
    const vpcCidrBlock = new TerraformVariable(this, "vpc_cidr_block", {
      description: "VPC\u306ECidr\u30D6\u30ED\u30C3\u30AF",
      validation: [
        {
          errorMessage:
            'You must set the input variable \\"vpc_cidr_block\\" to the Private Address Space range of RFC 1918.',
          condition:
            '${can(regex("(^10\\\\..+)|(^172\\\\.(1[6-9]|2[0-9]|3[0-1])\\\\..+)|(^192\\\\.168\\\\..+)", var.vpc_cidr_block))}',
        },
      ],
      type: VariableType.STRING,
    });
    const azCount = Fn.lengthOf(azSuffixes.value);
    const databaseSubnetsPrefixes =
      "${[ for num in ${" +
      Fn.range(
        Token.asNumber(Op.mul(azCount, 2)),
        Token.asNumber(Op.mul(azCount, 3))
      ) +
      "} : num]}";
    const enableFlowLogs = Op.eq(env.value, "prod");
    const publicSubnetsPrefixes =
      "${[ for num in ${" + Fn.range(0, Token.asNumber(azCount)) + "} : num]}";
    const vpcName = "${" + projectName.value + "}-vpc-${" + env.value + "}";
    const vpc = new Vpc.Vpc(this, "vpc", {
      assignIpv6AddressOnCreation: true,
      azs:
        "${[ for s in ${" +
        azSuffixes.value +
        '} : "${data.aws_region.current.name}${s}"]}',
      cidr: vpcCidrBlock.value,
      createDatabaseSubnetGroup: true,
      createDatabaseSubnetRouteTable: true,
      createEgressOnlyIgw: true,
      createFlowLogCloudwatchIamRole: enableFlowLogs,
      createFlowLogCloudwatchLogGroup: enableFlowLogs,
      createIgw: true,
      databaseSubnetIpv6Prefixes: databaseSubnetsPrefixes,
      databaseSubnets:
        "${[ for num in ${" +
        databaseSubnetsPrefixes +
        "} : cidrsubnet(var.vpc_cidr_block, 4, num)]}",
      defaultNetworkAclTags: [
        {
          Name: "${" + projectName.value + "}-default-acl-${" + env.value + "}",
        },
      ],
      defaultSecurityGroupTags: [
        {
          Name: "${" + projectName.value + "}-default-sg-${" + env.value + "}",
        },
      ],
      enableDhcpOptions: true,
      enableDnsHostnames: true,
      enableDnsSupport: true,
      enableFlowLog: enableFlowLogs,
      enableIpv6: true,
      enableNatGateway: false,
      enableVpnGateway: false,
      manageDefaultNetworkAcl: true,
      manageDefaultRouteTable: false,
      manageDefaultSecurityGroup: true,
      name: vpcName,
      publicSubnetIpv6Prefixes: publicSubnetsPrefixes,
      publicSubnets:
        "${[ for num in ${" +
        publicSubnetsPrefixes +
        "} : cidrsubnet(var.vpc_cidr_block, 4, num)]}",
    });
    /*In most cases loops should be handled in the programming language context and 
    not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
    you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
    you need to keep this like it is.*/
    const vpcTlsForEachIterator = TerraformIterator.fromList(
      Token.asAny(
        conditional(
          createSsmEndpoint.value,
          Fn.toset([vpc.vpcIdOutput]),
          Fn.toset([])
        )
      )
    );
    const vpcTls = new SecurityGroup(this, "vpc_tls", {
      description: "Allow TLS inbound traffic",
      ingress: [
        {
          cidrBlocks: [Token.asString(vpc.vpcCidrBlockOutput)],
          description: "TLS from VPC",
          fromPort: 443,
          protocol: "tcp",
          toPort: 443,
        },
      ],
      namePrefix: "${" + vpcName + "}-vpc_tls",
      vpcId: Token.asString(vpcTlsForEachIterator.value),
      forEach: vpcTlsForEachIterator,
    });
    new SecurityGroupRule(this, "vpc_default_self", {
      fromPort: 0,
      protocol: "all",
      securityGroupId: Token.asString(vpc.defaultSecurityGroupIdOutput),
      sourceSecurityGroupId: Token.asString(vpc.defaultSecurityGroupIdOutput),
      toPort: 0,
      type: "ingress",
    });
    new DataAwsRegion(this, "current", {});
    new TerraformOutput(this, "outputs", {
      value: vpc,
    });
    new VpcEndpoints.VpcEndpoints(this, "endpoints", {
      endpoints: [
        {
          ec2messages: [
            {
              private_dns_enabled: true,
              service: "ec2messages",
              subnet_ids: vpc.privateSubnetsOutput,
            },
          ],
          ssm: [
            {
              private_dns_enabled: true,
              security_group_ids: [
                Fn.lookupNested(Fn.lookupNested(vpcTls, [vpc.vpcIdOutput]), [
                  "id",
                ]),
              ],
              service: "ssm",
              subnet_ids: vpc.privateSubnetsOutput,
            },
          ],
          ssmmessages: [
            {
              private_dns_enabled: true,
              service: "ssmmessages",
              subnet_ids: vpc.privateSubnetsOutput,
            },
          ],
        },
      ],
      forEach: conditional(
        createSsmEndpoint.value,
        Fn.toset([vpc.vpcIdOutput]),
        Fn.toset([])
      ),
      securityGroupIds: [vpc.defaultSecurityGroupIdOutput],
      vpcId: "${each.value}",
    });
  }
}
